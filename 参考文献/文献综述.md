## Engineering Record and Replay for Deployability

### 工程记录和重播以进行部署性

使用低开销记录和重播程序执行的能力使许多应用程序（例如反向执行调试，难以重现的测试故障调试，以及“黑匣子”在部署系统中的故障分析。现有的记录和重放方法通过录制整个虚拟机（重量级）（重量级）来修改OS内核（添加部署和维护成本），需要普遍的代码仪器（施加显着性能和复杂性开销），或修改编译器和运行时系统（限制一般性）。我们调查了是否有可能构建实用的记录和重播系统，避免所有这些问题。答案结果是肯定的 - 如果CPU和操作系统符合某些非明显的约束。幸运的是，幸运的是现代英特尔CPU，Linux内核和用户空间框架确实满足了这些约束，但最近这只会变为真实。具有一些新颖的优化，我们的系统RR记录并重播具有低开销的现实世界的低行性工作负载，具有完全用户空间实现，使用库存硬件，编译器，运行时和操作系统。 RR构成开源反向执行调试器的基础，从实践中显着使用。我们介绍了RR的设计和实现，描述了它在各种工作负载上的性能，并识别支持我们方法所需的硬件和操作系统设计的约束。



## Curious Containers: A framework for computational reproducibility in life sciences with support for Deep Learning applications

**[好奇的容器：生命科学中计算可重复性的框架，并支持深度学习应用程序](https://www.x-mol.com/paperRedirect/1262481140207427584)**
[*Future Generation Computer Systems*](https://www.x-mol.com/paper/journal/111430?r_detail=1262481140207427584&readMode=zh) ( IF 7.187 ) **Pub Date : 2020-05-18** , DOI: [10.1016/j.future.2020.05.007](https://www.x-mol.com/paperRedirect/1262481140207427584)
Christoph Jansen, Jonas Annuscheit, Bruno Schilling, Klaus Strohmenger, Michael Witt, Felix Bartusch, Christian Herta, Peter Hufnagl, Dagmar Krefting



在临床场景中，人们对复杂的计算实验越来越感兴趣，例如深度学习模型的训练。可重复性是此类实验的基本属性，尤其是如果结果有助于患者的治疗时。本文介绍了Curious Containers，这是一个用于计算可重现性的软件框架，该框架将数据，软件和运行时环境视为分散的网络资源。所有实验资源均使用与通用工作流语言的子集兼容的新格式在单个文件中描述。Docker用于在容器映像中部署实验软件，包括用于与现有存储解决方案连接的任意数据传输程序。该框架支持深度学习应用程序，对存储和处理能力有很高的要求。可以通过基于用户空间技术中文件系统的SSHFS之类的网络文件系统将大型数据集安装在容器内。Nvidia-Container-Toolkit支持GPU使用。好奇容器已在两种生物医学场景中进行了测试。第一个用例是深度学习应用程序，用于图像中的肿瘤分类，需要大型数据集和GPU。在这种情况下，已经开发出框架与用于探索性深度学习建模的现有数据版本控制系统的原型集成。第二个用例扩展了现有的容器图像，包括用于检测和比较质谱数据中人类蛋白质的科学工作流程。容器映像最初是为归档平台开发的，可以扩展为与Curious Containers和cwltool（通用工作流语言参考实现）兼容。提出的解决方案允许对计算实验进行一致的描述和执行，同时力求灵活且可与现有软件和标准互操作。随着越来越多的系统将其验证为医学决策支持系统，对深度学习实验的支持变得越来越重要。



## 相关工作

## 

Record-and-replay (RnR) 系统与 DetTrace 类似，需要拦截非确定性的来源。 然而，记录和回放系统并不能直接促进可重现的构建，因为不透明的记录文件无法检查包的源代码。 录音也需要存储，通常比纯源代码要多得多。 我们使用 rr 工具的最新版本 (5.2.0) 进行了一个小型实验，因为它是我们所知道的最强大的 RnR 系统。 我们选择了 81 个在 Ubuntu 18.04 中从源代码本地构建的包（为 rr 提供比 Debian Wheezy 更现代的构建环境），并尝试使用 rr 构建它们。 不幸的是，由于不支持 ioctl 调用的已知错误，rr 在其中的 46 个上崩溃了。 在使用 rr 构建的 35 个包中，平均运行时开销为 5.8 倍（范围为 3.3-22.7 倍），与 DetTrace 相当。 与 RnR 不同，DetTrace 避免了不透明的记录，并提供了从输入到输出的人类可读的审计跟踪 



DetTrace 独特的可重现容器抽象从许多以前的系统中汲取灵感。我们将之前的工作分为记录和回放系统和确定性执行系统。

学术界 [40-46] 和工业界 [47-49] 都提出了许多记录和回放 (RnR) 系统。这些系统记录一个非确定性执行的跟踪，以启用该执行的后续重放，通常用于调试目的。这些系统具有与 DetTrace 大致相似的拦截要求，因为系统调用是重现性的主要来源，必须记录在跟踪中。 DetTrace 借鉴了 Mozilla 的 RnR [47] 的一些实现技术，因为它还依赖于 ptrace（与 rr 的定量比较出现在第 7.1.3 节）。许多 RnR 系统以多线程工作负载为目标，因为这些工作负载在没有 RnR 支持的情况下调试起来非常具有挑战性，并且提供了高性能的并行记录和回放。确定性执行方案在程序执行期间强制执行确定性。

确定性操作系统解决了我们在本文中描述的几个系统问题，提供了确定性版本的操作系统抽象，如进程和线程。虽然 Determinator [12] 为确定性 fork-join 并行提供了新的 OS 抽象，而 DDOS [13] 专注于本地网络交互，但 dOS [14] 在提供确定性进程组抽象方面更接近我们的工作。 dOS 中的 shim 抽象与 Linux 的 ptrace API 相似。与 DetTrace 不同，dOS 支持线程和进程的并行执行。然而，dOS 使用 RnR 进行文件系统交互，将其确定性抽象的边界定义得太窄，对于与文件系统进行广泛交互的软件构建来说是有用的。更一般地说，自定义操作系统是执行确定性计算的重量级先决条件，而现有的确定性操作系统尚未评估跨不同微架构的可移植性。

其他确定性执行方案侧重于单个多线程进程，通过共享内存确定交互。一些方案针对任意二进制程序[50-58]，以适度的性能开销提供通用性。其他方案利用语言支持为 Haskell [10, 26, 59-62] 或 Java [9, 63] 程序提供确定性。无论是语言无关的还是特定的，这些方法都消除了线程调度的影响，但不能确定与底层操作系统和文件系统的 IO 交互。因此，它们的保证范围太小，无法用于可重现的构建。一个例外是 DetFlow [11]，它为批处理作业提供确定性并行执行，尽管它缺乏强大的系统调用拦截并且需要用 Haskell 编写的协调器层。





### 确定性操作系统

# Efficient system-enforced deterministic parallelism

确定性执行为调试，容错和安全性提供了许多好处。然而，当前正在确定并确定的并行程序的方法通常会产生高成本，允许行为错误的软件打败可重复性，并将时间依赖的比赛转换为输入或路径依赖的比赛而不消除它们。我们介绍了一个新的并行编程模型，解决了这些问题，并使用确定器，概念验证操作系统，以展示模型的实用性。确定器的Microkernel应用程序编程接口（API）只提供“共享无”地址空间和确定性的进程通信基元，以执行所有未经专业的代码---表现良好的---正常可重复。在此Microkernel上，确定器的用户级运行时为线程和过程级并行编程提供私有工作区模型。该模型避免引入读/写数据比赛，并转换写入/写入比赛以可靠地检测到的冲突。粗粒化并行基准测试和比较与非确定性系统相当，在多核PC上和分布式集群中的节点上。







